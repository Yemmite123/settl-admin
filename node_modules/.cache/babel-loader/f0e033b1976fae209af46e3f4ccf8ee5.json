{"ast":null,"code":"import { SCHEDULE, INVOKE, ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, EVENT_TARGET } from '../constants';\nimport { apmSymbol } from './patch-utils';\nvar eventTypes = ['click'];\nvar eventTypeSymbols = {};\n\nfor (var i = 0; i < eventTypes.length; i++) {\n  var et = eventTypes[i];\n  eventTypeSymbols[et] = apmSymbol(et);\n}\n\nfunction shouldInstrumentEvent(target, eventType, listenerFn) {\n  return target instanceof Element && eventTypes.indexOf(eventType) >= 0 && typeof listenerFn === 'function';\n}\n\nexport function patchEventTarget(callback) {\n  if (!window.EventTarget) {\n    return;\n  }\n\n  var proto = window.EventTarget.prototype;\n  var nativeAddEventListener = proto[ADD_EVENT_LISTENER_STR];\n  var nativeRemoveEventListener = proto[REMOVE_EVENT_LISTENER_STR];\n\n  function findTaskIndex(existingTasks, eventType, listenerFn, capture) {\n    for (var _i = 0; _i < existingTasks.length; _i++) {\n      var task = existingTasks[_i];\n\n      if (task.eventType === eventType && task.listenerFn === listenerFn && task.capture === capture) {\n        return _i;\n      }\n    }\n\n    return -1;\n  }\n\n  function isCapture(options) {\n    var capture;\n\n    if (typeof options === 'boolean') {\n      capture = options;\n    } else {\n      capture = options ? !!options.capture : false;\n    }\n\n    return capture;\n  }\n\n  function createListenerWrapper(target, eventType, listenerFn, options) {\n    var eventSymbol = eventTypeSymbols[eventType];\n    if (!eventSymbol) return listenerFn;\n    var existingTasks = target[eventSymbol];\n    var capture = isCapture(options);\n\n    if (existingTasks) {\n      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);\n\n      if (taskIndex !== -1) {\n        var _task = existingTasks[taskIndex];\n        return _task.wrappingFn;\n      }\n    } else {\n      existingTasks = target[eventSymbol] = [];\n    }\n\n    var task = {\n      source: EVENT_TARGET,\n      target: target,\n      eventType: eventType,\n      listenerFn: listenerFn,\n      capture: capture,\n      wrappingFn: wrappingFn\n    };\n    existingTasks.push(task);\n\n    function wrappingFn() {\n      callback(SCHEDULE, task);\n      var result;\n\n      try {\n        result = listenerFn.apply(this, arguments);\n      } finally {\n        callback(INVOKE, task);\n      }\n\n      return result;\n    }\n\n    return wrappingFn;\n  }\n\n  function getWrappingFn(target, eventType, listenerFn, options) {\n    var eventSymbol = eventTypeSymbols[eventType];\n    var existingTasks = target[eventSymbol];\n\n    if (existingTasks) {\n      var capture = isCapture(options);\n      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);\n\n      if (taskIndex !== -1) {\n        var task = existingTasks[taskIndex];\n        existingTasks.splice(taskIndex, 1);\n\n        if (existingTasks.length === 0) {\n          target[eventSymbol] = undefined;\n        }\n\n        return task.wrappingFn;\n      }\n    }\n\n    return listenerFn;\n  }\n\n  proto[ADD_EVENT_LISTENER_STR] = function (eventType, listenerFn, optionsOrCapture) {\n    var target = this;\n\n    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {\n      return nativeAddEventListener.apply(target, arguments);\n    }\n\n    var wrappingListenerFn = createListenerWrapper(target, eventType, listenerFn, optionsOrCapture);\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = wrappingListenerFn;\n    return nativeAddEventListener.apply(target, args);\n  };\n\n  proto[REMOVE_EVENT_LISTENER_STR] = function (eventType, listenerFn, optionsOrCapture) {\n    var target = this;\n\n    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {\n      return nativeRemoveEventListener.apply(target, arguments);\n    }\n\n    var wrappingFn = getWrappingFn(target, eventType, listenerFn, optionsOrCapture);\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = wrappingFn;\n    return nativeRemoveEventListener.apply(target, args);\n  };\n}","map":{"version":3,"sources":["/Users/adebayooluyemi/Documents/THE BULB/UPDATED SETTL ADMIN BACKOFFICE /settl-backoffice/node_modules/@elastic/apm-rum-core/dist/es/common/patching/event-target-patch.js"],"names":["SCHEDULE","INVOKE","ADD_EVENT_LISTENER_STR","REMOVE_EVENT_LISTENER_STR","EVENT_TARGET","apmSymbol","eventTypes","eventTypeSymbols","i","length","et","shouldInstrumentEvent","target","eventType","listenerFn","Element","indexOf","patchEventTarget","callback","window","EventTarget","proto","prototype","nativeAddEventListener","nativeRemoveEventListener","findTaskIndex","existingTasks","capture","_i","task","isCapture","options","createListenerWrapper","eventSymbol","taskIndex","_task","wrappingFn","source","push","result","apply","arguments","getWrappingFn","splice","undefined","optionsOrCapture","wrappingListenerFn","args","Array","slice","call"],"mappings":"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","sourcesContent":["import { SCHEDULE, INVOKE, ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, EVENT_TARGET } from '../constants';\nimport { apmSymbol } from './patch-utils';\nvar eventTypes = ['click'];\nvar eventTypeSymbols = {};\n\nfor (var i = 0; i < eventTypes.length; i++) {\n  var et = eventTypes[i];\n  eventTypeSymbols[et] = apmSymbol(et);\n}\n\nfunction shouldInstrumentEvent(target, eventType, listenerFn) {\n  return target instanceof Element && eventTypes.indexOf(eventType) >= 0 && typeof listenerFn === 'function';\n}\n\nexport function patchEventTarget(callback) {\n  if (!window.EventTarget) {\n    return;\n  }\n\n  var proto = window.EventTarget.prototype;\n  var nativeAddEventListener = proto[ADD_EVENT_LISTENER_STR];\n  var nativeRemoveEventListener = proto[REMOVE_EVENT_LISTENER_STR];\n\n  function findTaskIndex(existingTasks, eventType, listenerFn, capture) {\n    for (var _i = 0; _i < existingTasks.length; _i++) {\n      var task = existingTasks[_i];\n\n      if (task.eventType === eventType && task.listenerFn === listenerFn && task.capture === capture) {\n        return _i;\n      }\n    }\n\n    return -1;\n  }\n\n  function isCapture(options) {\n    var capture;\n\n    if (typeof options === 'boolean') {\n      capture = options;\n    } else {\n      capture = options ? !!options.capture : false;\n    }\n\n    return capture;\n  }\n\n  function createListenerWrapper(target, eventType, listenerFn, options) {\n    var eventSymbol = eventTypeSymbols[eventType];\n    if (!eventSymbol) return listenerFn;\n    var existingTasks = target[eventSymbol];\n    var capture = isCapture(options);\n\n    if (existingTasks) {\n      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);\n\n      if (taskIndex !== -1) {\n        var _task = existingTasks[taskIndex];\n        return _task.wrappingFn;\n      }\n    } else {\n      existingTasks = target[eventSymbol] = [];\n    }\n\n    var task = {\n      source: EVENT_TARGET,\n      target: target,\n      eventType: eventType,\n      listenerFn: listenerFn,\n      capture: capture,\n      wrappingFn: wrappingFn\n    };\n    existingTasks.push(task);\n\n    function wrappingFn() {\n      callback(SCHEDULE, task);\n      var result;\n\n      try {\n        result = listenerFn.apply(this, arguments);\n      } finally {\n        callback(INVOKE, task);\n      }\n\n      return result;\n    }\n\n    return wrappingFn;\n  }\n\n  function getWrappingFn(target, eventType, listenerFn, options) {\n    var eventSymbol = eventTypeSymbols[eventType];\n    var existingTasks = target[eventSymbol];\n\n    if (existingTasks) {\n      var capture = isCapture(options);\n      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);\n\n      if (taskIndex !== -1) {\n        var task = existingTasks[taskIndex];\n        existingTasks.splice(taskIndex, 1);\n\n        if (existingTasks.length === 0) {\n          target[eventSymbol] = undefined;\n        }\n\n        return task.wrappingFn;\n      }\n    }\n\n    return listenerFn;\n  }\n\n  proto[ADD_EVENT_LISTENER_STR] = function (eventType, listenerFn, optionsOrCapture) {\n    var target = this;\n\n    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {\n      return nativeAddEventListener.apply(target, arguments);\n    }\n\n    var wrappingListenerFn = createListenerWrapper(target, eventType, listenerFn, optionsOrCapture);\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = wrappingListenerFn;\n    return nativeAddEventListener.apply(target, args);\n  };\n\n  proto[REMOVE_EVENT_LISTENER_STR] = function (eventType, listenerFn, optionsOrCapture) {\n    var target = this;\n\n    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {\n      return nativeRemoveEventListener.apply(target, arguments);\n    }\n\n    var wrappingFn = getWrappingFn(target, eventType, listenerFn, optionsOrCapture);\n    var args = Array.prototype.slice.call(arguments);\n    args[1] = wrappingFn;\n    return nativeRemoveEventListener.apply(target, args);\n  };\n}"]},"metadata":{},"sourceType":"module"}