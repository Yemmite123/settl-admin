{"ast":null,"code":"import { LONG_TASK, LARGEST_CONTENTFUL_PAINT, FIRST_CONTENTFUL_PAINT, FIRST_INPUT, LAYOUT_SHIFT } from '../common/constants';\nimport { noop, PERF } from '../common/utils';\nimport Span from './span';\nexport var metrics = {\n  fid: 0,\n  fcp: 0,\n  tbt: {\n    start: Infinity,\n    duration: 0\n  },\n  cls: 0,\n  longtask: {\n    count: 0,\n    duration: 0,\n    max: 0\n  }\n};\nvar LONG_TASK_THRESHOLD = 50;\nexport function createLongTaskSpans(longtasks, agg) {\n  var spans = [];\n\n  for (var i = 0; i < longtasks.length; i++) {\n    var _longtasks$i = longtasks[i],\n        name = _longtasks$i.name,\n        startTime = _longtasks$i.startTime,\n        duration = _longtasks$i.duration,\n        attribution = _longtasks$i.attribution;\n    var end = startTime + duration;\n    var span = new Span(\"Longtask(\" + name + \")\", LONG_TASK, {\n      startTime: startTime\n    });\n    agg.count++;\n    agg.duration += duration;\n    agg.max = Math.max(duration, agg.max);\n\n    if (attribution.length > 0) {\n      var _attribution$ = attribution[0],\n          _name = _attribution$.name,\n          containerType = _attribution$.containerType,\n          containerName = _attribution$.containerName,\n          containerId = _attribution$.containerId;\n      var customContext = {\n        attribution: _name,\n        type: containerType\n      };\n\n      if (containerName) {\n        customContext.name = containerName;\n      }\n\n      if (containerId) {\n        customContext.id = containerId;\n      }\n\n      span.addContext({\n        custom: customContext\n      });\n    }\n\n    span.end(end);\n    spans.push(span);\n  }\n\n  return spans;\n}\nexport function createFirstInputDelaySpan(fidEntries) {\n  var firstInput = fidEntries[0];\n\n  if (firstInput) {\n    var startTime = firstInput.startTime,\n        processingStart = firstInput.processingStart;\n    var span = new Span('First Input Delay', FIRST_INPUT, {\n      startTime: startTime\n    });\n    span.end(processingStart);\n    return span;\n  }\n}\nexport function createTotalBlockingTimeSpan(tbtObject) {\n  var start = tbtObject.start,\n      duration = tbtObject.duration;\n  var tbtSpan = new Span('Total Blocking Time', LONG_TASK, {\n    startTime: start\n  });\n  tbtSpan.end(start + duration);\n  return tbtSpan;\n}\nexport function calculateTotalBlockingTime(longtaskEntries) {\n  longtaskEntries.forEach(function (entry) {\n    var name = entry.name,\n        startTime = entry.startTime,\n        duration = entry.duration;\n\n    if (startTime < metrics.fcp) {\n      return;\n    }\n\n    if (name !== 'self' && name.indexOf('same-origin') === -1) {\n      return;\n    }\n\n    metrics.tbt.start = Math.min(metrics.tbt.start, startTime);\n    var blockingTime = duration - LONG_TASK_THRESHOLD;\n\n    if (blockingTime > 0) {\n      metrics.tbt.duration += blockingTime;\n    }\n  });\n}\nexport function calculateCumulativeLayoutShift(clsEntries) {\n  clsEntries.forEach(function (entry) {\n    if (!entry.hadRecentInput && entry.value) {\n      metrics.cls += entry.value;\n    }\n  });\n}\nexport function captureObserverEntries(list, _ref) {\n  var isHardNavigation = _ref.isHardNavigation,\n      trStart = _ref.trStart;\n  var longtaskEntries = list.getEntriesByType(LONG_TASK).filter(function (entry) {\n    return entry.startTime >= trStart;\n  });\n  var longTaskSpans = createLongTaskSpans(longtaskEntries, metrics.longtask);\n  var result = {\n    spans: longTaskSpans,\n    marks: {}\n  };\n\n  if (!isHardNavigation) {\n    return result;\n  }\n\n  var lcpEntries = list.getEntriesByType(LARGEST_CONTENTFUL_PAINT);\n  var lastLcpEntry = lcpEntries[lcpEntries.length - 1];\n\n  if (lastLcpEntry) {\n    var lcp = parseInt(lastLcpEntry.startTime);\n    metrics.lcp = lcp;\n    result.marks.largestContentfulPaint = lcp;\n  }\n\n  var timing = PERF.timing;\n  var unloadDiff = timing.fetchStart - timing.navigationStart;\n  var fcpEntry = list.getEntriesByName(FIRST_CONTENTFUL_PAINT)[0];\n\n  if (fcpEntry) {\n    var fcp = parseInt(unloadDiff >= 0 ? fcpEntry.startTime - unloadDiff : fcpEntry.startTime);\n    metrics.fcp = fcp;\n    result.marks.firstContentfulPaint = fcp;\n  }\n\n  var fidEntries = list.getEntriesByType(FIRST_INPUT);\n  var fidSpan = createFirstInputDelaySpan(fidEntries);\n\n  if (fidSpan) {\n    metrics.fid = fidSpan.duration();\n    result.spans.push(fidSpan);\n  }\n\n  calculateTotalBlockingTime(longtaskEntries);\n  var clsEntries = list.getEntriesByType(LAYOUT_SHIFT);\n  calculateCumulativeLayoutShift(clsEntries);\n  return result;\n}\nexport var PerfEntryRecorder = function () {\n  function PerfEntryRecorder(callback) {\n    this.po = {\n      observe: noop,\n      disconnect: noop\n    };\n\n    if (window.PerformanceObserver) {\n      this.po = new PerformanceObserver(callback);\n    }\n  }\n\n  var _proto = PerfEntryRecorder.prototype;\n\n  _proto.start = function start(type) {\n    try {\n      this.po.observe({\n        type: type,\n        buffered: true\n      });\n    } catch (_) {}\n  };\n\n  _proto.stop = function stop() {\n    this.po.disconnect();\n  };\n\n  return PerfEntryRecorder;\n}();","map":{"version":3,"sources":["/Users/adebayooluyemi/Documents/THE BULB/UPDATED SETTL ADMIN BACKOFFICE /OLUYEMI SETTL TESTING FOR ADMIN/node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/metrics.js"],"names":["LONG_TASK","LARGEST_CONTENTFUL_PAINT","FIRST_CONTENTFUL_PAINT","FIRST_INPUT","LAYOUT_SHIFT","noop","PERF","Span","metrics","fid","fcp","tbt","start","Infinity","duration","cls","longtask","count","max","LONG_TASK_THRESHOLD","createLongTaskSpans","longtasks","agg","spans","i","length","_longtasks$i","name","startTime","attribution","end","span","Math","_attribution$","_name","containerType","containerName","containerId","customContext","type","id","addContext","custom","push","createFirstInputDelaySpan","fidEntries","firstInput","processingStart","createTotalBlockingTimeSpan","tbtObject","tbtSpan","calculateTotalBlockingTime","longtaskEntries","forEach","entry","indexOf","min","blockingTime","calculateCumulativeLayoutShift","clsEntries","hadRecentInput","value","captureObserverEntries","list","_ref","isHardNavigation","trStart","getEntriesByType","filter","longTaskSpans","result","marks","lcpEntries","lastLcpEntry","lcp","parseInt","largestContentfulPaint","timing","unloadDiff","fetchStart","navigationStart","fcpEntry","getEntriesByName","firstContentfulPaint","fidSpan","PerfEntryRecorder","callback","po","observe","disconnect","window","PerformanceObserver","_proto","prototype","buffered","_","stop"],"mappings":"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","sourcesContent":["import { LONG_TASK, LARGEST_CONTENTFUL_PAINT, FIRST_CONTENTFUL_PAINT, FIRST_INPUT, LAYOUT_SHIFT } from '../common/constants';\nimport { noop, PERF } from '../common/utils';\nimport Span from './span';\nexport var metrics = {\n  fid: 0,\n  fcp: 0,\n  tbt: {\n    start: Infinity,\n    duration: 0\n  },\n  cls: 0,\n  longtask: {\n    count: 0,\n    duration: 0,\n    max: 0\n  }\n};\nvar LONG_TASK_THRESHOLD = 50;\nexport function createLongTaskSpans(longtasks, agg) {\n  var spans = [];\n\n  for (var i = 0; i < longtasks.length; i++) {\n    var _longtasks$i = longtasks[i],\n        name = _longtasks$i.name,\n        startTime = _longtasks$i.startTime,\n        duration = _longtasks$i.duration,\n        attribution = _longtasks$i.attribution;\n    var end = startTime + duration;\n    var span = new Span(\"Longtask(\" + name + \")\", LONG_TASK, {\n      startTime: startTime\n    });\n    agg.count++;\n    agg.duration += duration;\n    agg.max = Math.max(duration, agg.max);\n\n    if (attribution.length > 0) {\n      var _attribution$ = attribution[0],\n          _name = _attribution$.name,\n          containerType = _attribution$.containerType,\n          containerName = _attribution$.containerName,\n          containerId = _attribution$.containerId;\n      var customContext = {\n        attribution: _name,\n        type: containerType\n      };\n\n      if (containerName) {\n        customContext.name = containerName;\n      }\n\n      if (containerId) {\n        customContext.id = containerId;\n      }\n\n      span.addContext({\n        custom: customContext\n      });\n    }\n\n    span.end(end);\n    spans.push(span);\n  }\n\n  return spans;\n}\nexport function createFirstInputDelaySpan(fidEntries) {\n  var firstInput = fidEntries[0];\n\n  if (firstInput) {\n    var startTime = firstInput.startTime,\n        processingStart = firstInput.processingStart;\n    var span = new Span('First Input Delay', FIRST_INPUT, {\n      startTime: startTime\n    });\n    span.end(processingStart);\n    return span;\n  }\n}\nexport function createTotalBlockingTimeSpan(tbtObject) {\n  var start = tbtObject.start,\n      duration = tbtObject.duration;\n  var tbtSpan = new Span('Total Blocking Time', LONG_TASK, {\n    startTime: start\n  });\n  tbtSpan.end(start + duration);\n  return tbtSpan;\n}\nexport function calculateTotalBlockingTime(longtaskEntries) {\n  longtaskEntries.forEach(function (entry) {\n    var name = entry.name,\n        startTime = entry.startTime,\n        duration = entry.duration;\n\n    if (startTime < metrics.fcp) {\n      return;\n    }\n\n    if (name !== 'self' && name.indexOf('same-origin') === -1) {\n      return;\n    }\n\n    metrics.tbt.start = Math.min(metrics.tbt.start, startTime);\n    var blockingTime = duration - LONG_TASK_THRESHOLD;\n\n    if (blockingTime > 0) {\n      metrics.tbt.duration += blockingTime;\n    }\n  });\n}\nexport function calculateCumulativeLayoutShift(clsEntries) {\n  clsEntries.forEach(function (entry) {\n    if (!entry.hadRecentInput && entry.value) {\n      metrics.cls += entry.value;\n    }\n  });\n}\nexport function captureObserverEntries(list, _ref) {\n  var isHardNavigation = _ref.isHardNavigation,\n      trStart = _ref.trStart;\n  var longtaskEntries = list.getEntriesByType(LONG_TASK).filter(function (entry) {\n    return entry.startTime >= trStart;\n  });\n  var longTaskSpans = createLongTaskSpans(longtaskEntries, metrics.longtask);\n  var result = {\n    spans: longTaskSpans,\n    marks: {}\n  };\n\n  if (!isHardNavigation) {\n    return result;\n  }\n\n  var lcpEntries = list.getEntriesByType(LARGEST_CONTENTFUL_PAINT);\n  var lastLcpEntry = lcpEntries[lcpEntries.length - 1];\n\n  if (lastLcpEntry) {\n    var lcp = parseInt(lastLcpEntry.startTime);\n    metrics.lcp = lcp;\n    result.marks.largestContentfulPaint = lcp;\n  }\n\n  var timing = PERF.timing;\n  var unloadDiff = timing.fetchStart - timing.navigationStart;\n  var fcpEntry = list.getEntriesByName(FIRST_CONTENTFUL_PAINT)[0];\n\n  if (fcpEntry) {\n    var fcp = parseInt(unloadDiff >= 0 ? fcpEntry.startTime - unloadDiff : fcpEntry.startTime);\n    metrics.fcp = fcp;\n    result.marks.firstContentfulPaint = fcp;\n  }\n\n  var fidEntries = list.getEntriesByType(FIRST_INPUT);\n  var fidSpan = createFirstInputDelaySpan(fidEntries);\n\n  if (fidSpan) {\n    metrics.fid = fidSpan.duration();\n    result.spans.push(fidSpan);\n  }\n\n  calculateTotalBlockingTime(longtaskEntries);\n  var clsEntries = list.getEntriesByType(LAYOUT_SHIFT);\n  calculateCumulativeLayoutShift(clsEntries);\n  return result;\n}\nexport var PerfEntryRecorder = function () {\n  function PerfEntryRecorder(callback) {\n    this.po = {\n      observe: noop,\n      disconnect: noop\n    };\n\n    if (window.PerformanceObserver) {\n      this.po = new PerformanceObserver(callback);\n    }\n  }\n\n  var _proto = PerfEntryRecorder.prototype;\n\n  _proto.start = function start(type) {\n    try {\n      this.po.observe({\n        type: type,\n        buffered: true\n      });\n    } catch (_) {}\n  };\n\n  _proto.stop = function stop() {\n    this.po.disconnect();\n  };\n\n  return PerfEntryRecorder;\n}();"]},"metadata":{},"sourceType":"module"}